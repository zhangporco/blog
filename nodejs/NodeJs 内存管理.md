# NodeJs 内存管理

在**Node**中，**js**的运行时引擎是**chrome v8**，也就是说**node**为**v8**提供了一个宿主环境，
而**v8**为**js**提供了一个运行时环境，至此，他们三者的关系就比较清楚了。理解了这一点也就会明白**node**
内存管理是离不开**v8**的内存机制的（还有一部分是libuv "事件循环"）。

**Node** 受制于 **v8** 对内存用量的限制，对于物理机内存使用有限（64位系统约1.4G，32位系统约0.7G）。

- **v8** 限制 **js** 内存用量原因
	- **v8** 最初为浏览器而设计，不太可能有大内存场景
	- **v8** 垃圾回收太过耗时（1.5G 堆内存做一次小回收（只作用新生代）需要 50 毫秒，做一次非增量回收需要 1 秒），而在垃圾回收期间，**js** 执行线程会被挂起。

## node 启动时指定 v8 最大内存大小

1. `—max-old-space-sze`
2. `—max-new-space-size`

## 查看内存使用情况

```
// 查看进程的内存使用情况
> process.memoryUsage()
{ 
  rss: 28053504,
  heapTotal: 7028736,
  heapUsed: 3765808,
  external: 8451 
}
（以下单位都是字节）
```

- rss：进程常驻内存部分。进程的内存一部分是**rss**，其余部分在交换区（swap）或者文件系统（filesystem）中
- heapTotal：堆中总共申请的内存量
- heapUsed：堆中已使用内存量

上图可以看出堆中内存用量小于进程常驻内存用量，说明**Node**中的内存并非都是**v8**分配的，通常将那些不通过**v8**分配的内存称为**堆外内存**。**Node**的内存构成主要由通过**v8**分配的部分和**Node**自行分配的部分组成，受**v8**垃圾回收限制的主要是**v8**的堆内存。

```
### 查看系统总内存
> os.totalmem()
17179869184

### 查看系统闲置内存
> os.freemem()
17179869184
```

## 垃圾回收

- **v8** 内存分类
	- 新生代：存活时间较短的对象，若一对象经历过多次回收依然存在，将会晋升至老生代区，区域小但垃圾回收频繁
		- 通过 `—max-new-space-size` 设置新生代最大内存大小
	- 老生代：存活时间较长或常驻内存对象

- **v8** 垃圾回收算法
	- 新生代
		- **Scavenge**：将堆内存一分为二（每一部分空间成为**semispace**），处于使用中的**From**空间，以及处于闲置状态的**To**空间，我们所使用的数据都存储在**From**空间。当垃圾回收开始后，会将**From**空间存活的对象复制到**To**空间，然后释放**From**空间，最后将**From**与**To**角色互换。
			- 优点：速度快
			- 缺点：空间开销大，只能使用一半的堆内存空间
	- 老生代
		- **Mark-Sweep**：标记清除，将死亡对象标记出来，然后清理，会存在内存碎片
		- **Mark-Compact**：标记整理，当老生代空间无法接收新生代晋升过来的对象时触发次算法，整理老生代内存碎片。

上述三种基本算法都需要挂起**js**执行线程（全停顿），** Scavenge**算法执行较为频繁，但由于新生代空间较小且存活对象较少，所有速度较快，全停顿对他影响不大。而老生代因为空间较大且存活对象多，全堆垃圾回收会造成较长时延。
	
- 垃圾回收影响
    - 浏览器：影响较小，由于客户端程序通常不会接触到大内存（文件操作），特别是**chrome**这种每个选项卡都是一个独立的**v8**实例来说，性能几乎没有影响，而且**v8**的内存限制也不会造成什么影响
    - 服务端：服务端的特性决定了，内存占用确实会比客户端大很多，比如使用内存作为缓存的业务场景。由于**v8**垃圾回收时会挂起执行线程且**js**是单线程执行，垃圾回收是会产生影响的，特别是全堆垃圾回收。

### 高效使用内存

鉴于上文所述，如何高效使用内存就是要让垃圾回收高效执行。通常情况下，闭包以及全局变量都会引起老生代内存无法正常回收。

## 内存泄漏

在**Node**中内存泄漏的本质是原本应当回收的对象由于各种意外而没有被回收，晋升至老生代内存中，并常驻老生代，直至进程内存溢出，应用崩溃。

- 常见原因
	- 缓存
	- 队列消费不及时
	- 作用域未释放

### 缓存
缓存在应用中十分常见，可以有效节省资源。一旦命中缓存，就意味着节省了一次 I/O 时间。在**Node**中往往使用全局对象当作缓存，这意味着它将常驻老生代空间，垃圾回收无法对此对象进行处理。
而且使用对象键值对来缓存东西与严格意义上的缓存还有较大差距，严格意义的缓存有完善的过期策略，而普通键值对没有。
因此对于需要大量使用缓存的应用来说，较好的解决方案是使用进程外的缓存，进程本身不存储状态，比如**redis**等，这类软件有着良好的过期淘汰机制以及内存管理，不会影响**Node**进程性能。
- 进程外缓存优点
	- 减少常驻老生代空间的对象数量，减少老生代空间垃圾回收次数，提高效率
	- 可以方便实现进程间通信

### 队列
**js**实现队列最常用的就是数组，通常情况下队列的消费速度都远大于生成速度，此时通常不会产生内存泄漏。但是一旦消费速度低于生产速度，队列就会堆积。

- 常见解决方案
	- 控制队列长度
	- 包含超时机制